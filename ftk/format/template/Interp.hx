package ftk.format.template;

import hscript.Expr;

using hscript.Tools;

/**
 * @version 2.0.0
 * @author filt3rek
 */

class InterpError {
	public var source	(default,null)	: Null<String>;
	public var native	(default,null)	: Error;

	public function new( native : Error, ?source : String ){
		this.native		= native;
		this.source		= source;
	}

	public function toString(){
#if hscriptPos
		return source != null ? native.toString() + " : " + source.split( "\n" )[ native.line -1 ] : native.toString();
#else
		return native;
#end
	}
}

// "_" added to prevent https://github.com/HaxeFoundation/haxe/issues/10820
class _HScriptInterp extends hscript.Interp{
	override function call( o : Dynamic, f : Dynamic, args : Array<Dynamic> ) : Dynamic {
		function _call(){
			try{
				return Reflect.callMethod(o,f,args);
			}catch( e ){
				// Get errors infos
				error( ECustom( e.toString() ) );
				return null;
			}
		}
		return _call();
	}
}

class Interp {
	var hinterp			: _HScriptInterp;

	var runtimePos		: Bool;
	var currentSource	: String;

	var sourcesStack	: Array<String>;	// inclusions' sources
	var aSources		: Array<String>;	// functions' calls sources

	/*
	*	Run-time shortcut working like Macro.build.buildFromString()
	*	Usage : 
	*	```
	*	public function myFunction( arg1, arg2... ){
	*		var x = "foo";
	*		...
	*		ftk.format.template.Interp.buildFromString( "::x:: is not bar" );	// foo is not bar
	*	}
	*	```
	*	@param	content	: source template
	*	@param	?ctx	: Set of fields to include in hscript context
	*/

	public static function buildFromString( content : String, ?ctx : {} ){
		return new Interp().execute( new Parser().parse( content ), ctx );
	}

	/*  
	*	Run-time Interp's constructor
	*	
	*	@param	?runtimePos	: If set to true, it will manage source code if errors occurs, especially when using inclusions. true by dafault
	*	@param	?addStd		: If set to true, adds some standard haxe classes (Std, Math, Date, StringTools...)
	*
	*	Add `-D hscriptPos` to report error line related to hscript interpreter exprs generator. A bit slower when set to true.
	*/

	public function new( runtimePos = true, addStd = false ) {
		this.runtimePos	= runtimePos;
		hinterp 		= new _HScriptInterp();

		if( runtimePos ){
			sourcesStack	= [];
			aSources		= [];
			hinterp.variables.set( "__currentSource__", function( index ){
				currentSource	= aSources[ index ];
			} );
		}

		hinterp.variables.set( "__toString__", __toString__ );
		hinterp.variables.set( "__hscriptSource__", function ( __hscriptSource__ ){
			if( runtimePos ){	
				sourcesStack.push( currentSource );
				currentSource	= __hscriptSource__;
			}

			var ret	= execute( __hscriptSource__, true );

			if( runtimePos ){
				currentSource	= sourcesStack.pop();
			}
			return ret;
		} );

		if( addStd ){
			for( cname in Tools.stdClasses ){
				var path	= cname.split( "." );
				hinterp.variables.set( path[ path.length - 1 ], Type.resolveClass( cname ) );
			}
		}
	}

	public dynamic function __toString__( o : Null<Any> ) : String {
		return Std.string( o );
	}

	/*  
	*	Main function that interprets a template
	*	
	*	@param	hscriptSource	: hscript source code generated by template's Parser output
	*	@param	?ctx			: Set of fields to include in hscript context
	*	@param	?isInclusion	: Used internally.
	*
	*	Add `-D hscriptPos` to report error line related to hscript interpreter exprs generator. A bit slower when set to true.
	*/

	public function execute( hscriptSource : String, ?ctx : {}, isInclusion = false ) : String {
		if( runtimePos && !isInclusion ){
			currentSource	= hscriptSource;
		}
		if( ctx == null )	ctx	= {};
		for( field in Reflect.fields( ctx ) ){
			hinterp.variables.set( field, Reflect.field( ctx, field ) );
		}
		
		var expr	= new hscript.Parser().parseString( hscriptSource );
		if( runtimePos ){
			addSources( expr, hscriptSource );
		}
		try{
			if( !isInclusion ){
				return hinterp.execute( expr );
			}else{
				return @:privateAccess hinterp.exprReturn( expr );
			}
		}catch( e : InterpError ){
			throw e;
		}catch( e : Error ){
			throw new InterpError( e, runtimePos ? currentSource : null );
		}catch( e ){
#if hscriptPos
			var pos	= hinterp.posInfos();
			throw new InterpError( new Error( ECustom( e.message ), 0, 0, pos.fileName, pos.lineNumber ), runtimePos ? currentSource : null );
#else
			throw new InterpError( ECustom( e.message ), runtimePos ? currentSource : null );
#end
		}
	}

	/*  
	*	Helper function that "safetly" includes a template into another template
	*	
	*	@param	hscriptSource	: hscript source code generated by template's Parser output
	*
	*	Add `-D hscriptPos` to report error line related to hscript interpreter exprs generator. A bit slower when set to true.
	*/

	public function include( hscriptSource : String ){
		return execute( '__hscriptSource__( \'__s__+=${ escapeQuotes( hscriptSource ) }\' );', true );
	}

	//

	function addSources( expr : Expr, ?hscriptSource : String, ?index : Int ){
		if( hscriptSource != null ){
			aSources.push( hscriptSource );
			index	= aSources.length - 1;
		}
		switch #if hscriptPos expr.e #else expr #end {
			case EFunction(args, e, name, ret):
				if( name == "__currentSource__" || name == "__hscriptSource__" ){
					return;
				}else if( name == "__toString__"  ){
					expr.iter( addSources.bind(_, null, index ) );
					return;
				}

				switch #if hscriptPos e.e #else e #end {
					case EBlock( a )	: 
						a.unshift( ECall( EIdent( "__currentSource__" ).mk( e ), [ EConst( CInt( index ) ).mk( e ) ] ).mk( e ) );
					case _	:
				}
				e.iter( addSources.bind(_, null, index ) );

			case ECall(e, params):
				var name	= switch #if hscriptPos e.e #else e #end{
					case EIdent(v):	v;
					case _	: null;
				}
				if( name == "__currentSource__" || name == "__hscriptSource__" ){
					return;
				}else if( name == "__toString__"  ){
					expr.iter( addSources.bind(_, null, index ) );
					return;
				}
				
				var tmpName			= "call_" + Math.round( Math.random() * 1000 );
				
				var ecall	= ECall( e, params ).mk( expr );
				var eblock	= EBlock([ 
					EVar( tmpName, null, ecall ).mk( expr ),
					ECall( EIdent( "__currentSource__" ).mk( expr ), [ EConst( CInt( index ) ).mk( expr ) ] ).mk( expr ),
					EIdent( tmpName ).mk( expr ),
				]);
				#if hscriptPos expr.e #else expr #end	= eblock;
				ecall.iter( addSources.bind(_, null, index ) );
			case _	: 
				expr.iter( addSources.bind(_, null, index ) );
		}
	}

	//

	public static inline function escapeQuotes( s : String ){
		return s.split( '"' ).join( '\\"' ).split( "'" ).join( "\\'" );
	}
}